#回文树复习
##吐槽
	之前学过回文树之后，敲了一个apio的回文串和CC的一个LTIME23的题，结果好久没看回文树又忘了囧。。比赛的时候没能写出来。。。赶快认真的复习一下
##回文树的结构
	字符串中的自动机大都比较类似：
	后缀自动机中维护了（不讨论后缀树的ch边吧。。但是的确是在后缀树视角下讨论的）
		trans来维护从前面加入一个新字符之后到了哪里
		par边维护当前串在虚树中最长的前缀
	AC自动机中维护了
		ch边来维护从后面加入一个字符到了哪里
		fail边来维护当前串在AC自动机中的最长后缀
	我们考察维护这些信息的动机
	不难发现：
		trans边、ch边作用是使得加入一个字符后方便转移
		par边、fail边作用是使得后面一个字符不匹配之后可以往上跳找到一个最大匹配

		为什么par边维护前缀而fail边维护后缀呢，这是因为后缀自动机是往前加字符而AC自动机是往后加字符，当然一个维护最长前缀一个维护最长后缀了
		（当然这里也反映了字符串匹配的贪心性质，如果加入一个字符后不匹配了，那么我们就可以直接往后跳直到匹配，因为后面的子串肯定包含了这个不匹配的后缀的话，就可以直接丢弃这部分信息。或者可以理解为i的匹配长度只和i-1的最大匹配长度有关而和超出这个长度的无关。。或者理解为左端点单调。。）
	（值得一提的是par边和fail边最后都形成了树形的结构，可以方便信息的维护）

	所以我们在回文树中应该维护什么呢？
		我们建出来的是原串中的所有回文子串，需要支持从后面加入一个字符
		所以需要维护
			ch来维护从两边加入一个字符后到了哪里
			fail来维护最长的一个回文后缀
		其实回文结构性的信息就只有这两个，别的信息都是为了维护别的东西，在ch树上或者fail树上加上去的
##回文树的构建
	字符串自动机中，后缀自动机是增量法构造的，因为需要合并（或者缩起来）大量重复节点
	而AC自动机是，由于节点数很少，直接建出来，然后bfs求出fail边
	回文树的构建由于节点数需要合并到O(n)级别（否则是O(n^2)的），合并就是把本质不同的回文串并到一个点上，所以我们使用增量法构造。

	（以下内容是重点）
	构造的时候我们每次加入一个字符x，就check一下字符串的最长回文后缀（也就是上一个刚刚加入的节点）能否拓展到它，不能就顺着那个后缀对应的fail边跳，缩短这个回文后缀的长度，直到匹配或是跳到-1（相当于和自己匹配了）
	//这步肯定是均摊O(1)的因为每加入一个x匹配的长度增加O(1)，往上跳的次数不会超过匹配长度增加的次数

	然后我们判断下对应的回文后缀的ch[x]是否存在，如果存在直接返回，如果不存在，那么我们就新建一个节点表示这个新加入的回文子串，然后我们考虑建出它的fail边，我们只需要再顺着之前那个回文后缀的fail边往上跳，直到对应的回文后缀可以拓展出x为止。。然后我们考虑这个对应后缀的ch[x]，如果存在，那么显然应该作为我们新节点的fail边，
	但是如果不存在呢？

	xabcbax是匹配的，然后跳到了某个abcbax的后缀，发现匹配上了x，这时候ch[x]会不会不存在呢？是不会的因为由于回文串的对称性质，那一定也是xabcba的前缀，所以一定已经加入过了

	如果确实没有回文后缀，这个时候的fail边应该是指向x这个单个的节点，所以等于是一路跳到了rm1，然后在后面ch[x]了。。。

	（如果这里w已经是rm1了，那么我们这个p代表的回文串就是单个的x，那么就需要特判一下指向r0（其实相当于在-2的点ch[x]了一发233）)

	这也同时说明了为啥直接找一个最长的回文后缀匹配x，就可以加入所有以x结尾的回文串，因为按照它的回文中心对称下就可以得到所有更短的以x结尾的回文串！！！（这点非常重要！！是回文树得以存在的关键性质和思想。。充分利用了回文串本身的特性）

	所以直接不管ch[x]有没有都让fail等于它既可
##其它信息的维护
	维护每个回文串出现次数，直接记录每个回文串作为后缀最长匹配的出现次数，然后在fail树上前缀和一下即可

	维护每个回文串的长度。。。插入的时候直接从w + 2即可。。

	维护每个回文串长度小于等于它的一半的最长回文后缀。。。这个比较有趣（也比较重要）
		建出来的时候，我们建fail边是从w->f往前跳。。来构建的。。
		那么我们这个时候建hfail边，就从w->hfail往前跳直到匹配。。
		原因是p->hfail去掉左右x的字符之后，一定也是w的一个回文后缀并且长度小于等于它的一半
		(x/2 - 2) >= x/2
		但是反过来w->hfail托展x却不一定是p->hfail
		(x/2 + 2) < (x + 2) / 2 = x/2 + 1
		但是由于差的很小所以往上跳的次数是O(1)的（？），反正很少
		主要是在hf匹配x的地方跳的比较多，但是这里匹配的过程实际上和回文树本身的匹配是一样的。所以还是O(n)

		具体写起来我们先从f->hfail往上跳找到第一个可以拓展x的回文后缀，然后把它ch[x]拓展
		然后得到的这个新回文后缀一定在回文树中（回文串对称性，或者可以简单理解为此时所有回文子串都在回文树中）
		然后我们沿着这个新回文后缀的fail边往上跳缩短它的长度直到合法。。（边界是r0肯定合法嘛）

		代码：
		```cpp
			q = w->hf;
			for(;s[l - q->l - 1] - 'a' != x; q = q->f);
			q = q->ch[x];
			for(;(q->l << 1) > p->l;q = q->f);
			p->hf = q;
		```
